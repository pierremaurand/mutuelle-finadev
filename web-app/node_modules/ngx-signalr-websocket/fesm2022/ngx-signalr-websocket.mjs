import { fromFetch } from 'rxjs/fetch';
import { merge, map, Subject, of, take, debounceTime, switchMap, mergeAll, filter, tap, takeWhile, first } from 'rxjs';
import { webSocket } from 'rxjs/webSocket';

const isoDateFormat = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d*)?Z$/;
const parseIsoDateStrToDate = (_, value) => {
    if (typeof value === 'string' && isoDateFormat.test(value)) {
        return new Date(value);
    }
    return value;
};

const recordSeparator = String.fromCharCode(0x1e);
const pipeParsers = (...converters) => converters.reduce((a, b) => (name, value) => b(name, a(name, value)));
class TextMessageSerializer {
    constructor(propertyParsers) {
        if (propertyParsers && propertyParsers.length > 0) {
            this.reviver = pipeParsers(...propertyParsers);
        }
    }
    serialize(messages) {
        return messages.map(message => JSON.stringify(message)).join(recordSeparator) + recordSeparator;
    }
    deserialize({ data }) {
        const message = data;
        const lastIndex = message.length - recordSeparator.length;
        if (message[lastIndex] !== recordSeparator) {
            throw new Error('Message is incomplete.');
        }
        const jsonItems = message.substring(0, lastIndex).split(recordSeparator);
        return jsonItems.map(x => JSON.parse(x, this.reviver));
    }
}

class DefaultHttpPostClient {
    post(url, body) {
        return fromFetch(url, {
            method: 'POST', body, selector: response => {
                if (!response.ok) {
                    throw new Error(response.statusText);
                }
                return response.json();
            }
        });
    }
}

var MessageType;
(function (MessageType) {
    /** Indicates the message is an Invocation message and implements the {@link InvocationMessage} interface. */
    MessageType[MessageType["invocation"] = 1] = "invocation";
    /** Indicates the message is a StreamItem message and implements the {@link StreamItemMessage} interface. */
    MessageType[MessageType["streamItem"] = 2] = "streamItem";
    /** Indicates the message is a Completion message and implements the {@link CompletionMessage} interface. */
    MessageType[MessageType["completion"] = 3] = "completion";
    /** Indicates the message is a Stream Invocation message and implements the {@link StreamInvocationMessage} interface. */
    MessageType[MessageType["streamInvocation"] = 4] = "streamInvocation";
    /** Indicates the message is a Cancel Invocation message and implements the {@link CancelInvocationMessage} interface. */
    MessageType[MessageType["cancelInvocation"] = 5] = "cancelInvocation";
    /** Indicates the message is a Ping message and implements the {@link PingMessage} interface. */
    MessageType[MessageType["ping"] = 6] = "ping";
    /** Indicates the message is a Close message and implements the {@link CloseMessage} interface. */
    MessageType[MessageType["close"] = 7] = "close";
})(MessageType || (MessageType = {}));
const handshakeRequest = { protocol: 'json', version: 1 };
const pingMessage = { type: MessageType.ping };
const closeMessage = { type: MessageType.close };
const createInvocationMessage = (target, args, invocationId, headers) => ({
    type: MessageType.invocation,
    headers,
    invocationId,
    target,
    arguments: args
});
const createStreamInvocationMessage = (target, args, invocationId, headers) => ({
    type: MessageType.streamInvocation,
    headers,
    invocationId,
    target,
    arguments: args,
});
const createCancelInvocationMessage = (invocationId, headers) => ({
    type: MessageType.cancelInvocation,
    headers,
    invocationId
});

var Transport;
(function (Transport) {
    Transport["longPolling"] = "LongPolling";
    Transport["serverSentEvents"] = "ServerSentEvents";
    Transport["webSockets"] = "WebSockets";
})(Transport || (Transport = {}));
var TransferFormat;
(function (TransferFormat) {
    TransferFormat["binary"] = "Binary";
    TransferFormat["text"] = "Text";
})(TransferFormat || (TransferFormat = {}));

var SignalrConnectionState;
(function (SignalrConnectionState) {
    SignalrConnectionState[SignalrConnectionState["closed"] = 0] = "closed";
    SignalrConnectionState[SignalrConnectionState["opened"] = 1] = "opened";
    SignalrConnectionState[SignalrConnectionState["closing"] = 2] = "closing";
})(SignalrConnectionState || (SignalrConnectionState = {}));
/**
 * Represents a connection to a SignalR Hub.
 */
class SignalrConnection {
    get opened() { return !this.$maintenance.closed; }
    ;
    get state() {
        return merge(this.open$.pipe(map(() => SignalrConnectionState.opened)), this.close$.pipe(map(() => SignalrConnectionState.closed)), this.closing$.pipe(map(() => SignalrConnectionState.closing)));
    }
    /**
     * Creates new SignalR hub connection.
     *
     * @param url Connection URL.
     * @param serializer Messages serializer.
     */
    constructor(url, serializer, headersFactory) {
        this.serializer = serializer;
        this.headersFactory = headersFactory;
        this.timeout = 30_000;
        this.lastInvocationId = 0;
        this.open$ = new Subject();
        this.close$ = new Subject();
        this.closing$ = new Subject();
        this.getHeaders = (method, args) => this.headersFactory ? this.headersFactory(method, args).pipe(take(1)) : of(undefined);
        this.subject = webSocket({
            url,
            serializer: value => this.serializer.serialize(value),
            deserializer: event => this.serializer.deserialize(event),
            openObserver: this.open$,
            closeObserver: this.close$,
            closingObserver: this.closing$
        });
        this.$maintenance = this.subject
            .multiplex(() => [handshakeRequest], () => [closeMessage], (messages) => messages.some(({ type }) => type === MessageType.ping))
            .subscribe(_ => this.subject.next([pingMessage]));
        this.$timeout = this.subject.pipe(debounceTime(this.timeout)).subscribe(() => this.close());
    }
    /**
    * Invokes a streaming hub method on the server using the specified name and arguments.
    * The Observable returned by this method resolves when the server indicates it has finished invoking the stream.
    *
    * @param method The name of the server method to invoke.
    * @param args The arguments used to invoke the server method.
    * @returns An Observable that yields results from the server as they are received.
    */
    stream(method, ...args) {
        this.checkOpened();
        const invocationId = this.nextInvocationId();
        const stream = this.getHeaders(method, args)
            .pipe(switchMap(headers => this.subject.multiplex(() => [createStreamInvocationMessage(method, args, invocationId, headers)], () => [createCancelInvocationMessage(invocationId, headers)], messages => !!messages.find(x => x.invocationId === invocationId))));
        return stream.pipe(mergeAll(), filter(x => x.invocationId === invocationId), tap(message => {
            if (message.type === MessageType.completion) {
                const { error } = message;
                if (error) {
                    throw Error(error);
                }
            }
        }), takeWhile(message => message.type !== MessageType.completion), map(message => message.item));
    }
    /**
     * Invokes a hub method on the server using the specified name and arguments.
     * The Observable returned by this method resolves when the server indicates it has finished invoking the method.
     *
     * @param method The name of the server method to invoke.
     * @param args The arguments used to invoke the server method.
     * @returns An Observable with single result from the server.
     */
    invoke(method, ...args) {
        this.checkOpened();
        const invocationId = this.nextInvocationId();
        this.getHeaders(method, args)
            .pipe(map(headers => createInvocationMessage(method, args, invocationId, headers)))
            .subscribe(invocation => this.subject.next([invocation]));
        return this.subject
            .pipe(mergeAll(1), first(x => x.invocationId === invocationId), map(message => {
            const { error, result } = message;
            if (error) {
                throw Error(error);
            }
            return result;
        }));
    }
    /**
     * Subscribes to invocations with the specified method name.
     *
     * @param method The name of the hub method to define.
     * @returns Invocation's arguments Observable.
     */
    on(method) {
        this.checkOpened();
        return this.subject
            .pipe(mergeAll(), filter(({ target }) => target === method), map(message => message.arguments));
    }
    /**
     * Invokes a hub method on the server using the specified name and arguments.
     * Does not wait for a response from the receiver.
     *
     * @param method The name of the server method to invoke.
     * @param args The arguments used to invoke the server method.
     */
    send(method, ...args) {
        this.checkOpened();
        this.getHeaders(method, args)
            .pipe(map(headers => createInvocationMessage(method, args, undefined, headers)))
            .subscribe(invocation => this.subject.next([invocation]));
    }
    /**
     * Closes the connection to hub and terminates subscriptions.
     */
    close() {
        this.$timeout?.unsubscribe();
        this.$maintenance?.unsubscribe();
        this.subject.complete();
    }
    checkOpened() {
        if (!this.opened) {
            throw Error("Connection not opened");
        }
    }
    nextInvocationId() {
        this.lastInvocationId++;
        return this.lastInvocationId.toString();
    }
}

const defaultOptions = {
    propertyParsers: []
};
/**
 * SignalR client allows to connect to the hubs.
 */
class SignalrClient {
    /**
     * Creates new SignalR client.
     *
     * @param httpClient HTTP client performs HTTP requests.
     * @param options Optional: SignalR client options.
     */
    constructor(httpClient, options) {
        this.httpClient = httpClient;
        this.options = { ...defaultOptions, ...options };
        this.serializer = new TextMessageSerializer(this.options.propertyParsers);
    }
    /**
     * Creates new SignalR client.
     *
     * @param httpClient HTTP client performs HTTP requests.
     * @param configure Optional: provide action to configure SignalR client options.
     */
    static create(httpClient, configure) {
        let options = defaultOptions;
        if (configure) {
            configure(options);
        }
        return new SignalrClient(httpClient, options);
    }
    /**
     * Connects to SignalR hub.
     *
     * @param hubUrl SignalR hub endpoint URL.
     * @param accessToken Optional: access token used for client authorization.
     * @returns SignalR hub connection.
     */
    connect(hubUrl, accessToken) {
        return this.negotiate(hubUrl, accessToken)
            .pipe(map(connectionId => this.createConnection(hubUrl, connectionId, accessToken)));
    }
    negotiate(endpointBase, accessToken) {
        const url = new URL(`${endpointBase.replace(/\/$/, '')}/negotiate`, window.location.href);
        if (accessToken) {
            url.searchParams.append('access_token', accessToken);
        }
        return this.httpClient.post(url.href, null)
            .pipe(map(response => {
            if (!response.availableTransports
                .find(x => x.transport === Transport.webSockets && x.transferFormats.includes(TransferFormat.text))) {
                throw Error('SignalrClient supports only text WebSocket transport.');
            }
            return response.connectionId;
        }));
    }
    createConnection(endpointBase, connectionId, accessToken) {
        const url = new URL(endpointBase, window.location.href);
        url.protocol = url.protocol.replace(/^http/, 'ws');
        url.searchParams.append('id', connectionId);
        if (accessToken) {
            url.searchParams.append('access_token', accessToken);
        }
        return new SignalrConnection(url.href, this.serializer, this.options.headersFactory);
    }
}

/*
 * Public API Surface of ngx-signalr-websocket
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DefaultHttpPostClient, MessageType, SignalrClient, SignalrConnection, SignalrConnectionState, TextMessageSerializer, closeMessage, createCancelInvocationMessage, createInvocationMessage, createStreamInvocationMessage, handshakeRequest, parseIsoDateStrToDate, pingMessage };
//# sourceMappingURL=ngx-signalr-websocket.mjs.map
